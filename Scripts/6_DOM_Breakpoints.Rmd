---
title: "Breakpoints"
output: html_document
date: "2025-07-21"
---

## load packages and read in data
```{r}
## packages 
library(ggpubr) # for ggdensity
library(segmented) #for breakpoints
library(tidyverse)
library(patchwork) # so you can arragne figures by "/" or "|"

## read in chem data
chem <- read_csv("../Data/chemistry_joined.csv")   
    # filter(!(Site == 88 & Depth_m == 1.5)) |> 
    # filter(!(Site == 88 & Depth_m == 9)) |> 
    # filter(!(Site == 50 & Depth_m == 1.5)) |> 
    # filter(!(Site == 50 & Depth_m == 9))

```



############################ Gen chem viz ##############################################

##look at all the DOM comp

```{r}
#DOM comp options
levels <- c("BIX", "HIX", "FI", "Peak_A", "Peak_T", "A_T", "a254_m", "SUVA254")
levels <- c("BIX", "HIX", "A_T", "SUVA254")
#all variable options
levels <- c("DOC_mgL", "BIX", "HIX", "d18O_VSMOW", "d2H_VSMOW", "D_excess")
levels <- c("DOC_mgL", "DON_mgL", "BIX", "HIX", "A_T", "NO3NO2_ugL", "NH4_ugL", "SRP_ugL","D_excess")


#Across dates
chem |> 
  pivot_longer(-c(1:8)) |> 
  # filter(!Site %in% c(50,88,90)) |> #if wanting to zoom in on S1 - C1 transition
  filter(name %in% levels) |> 
  ggplot(aes(x = Distance, y = value, fill = Depth_m))+
   geom_point(shape = 21, size = 4) +
  facet_wrap(~factor(name, levels = levels), scales = "free_y")+
  theme_bw()+ theme(legend.position = "top", text = element_text(size = 18),
                    panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= "Distance from Stream (m)", fill = "Depth (m)")+
  scale_x_continuous(breaks = c(0, 500, 1000, 1500))+ 
  scale_fill_gradient2(low = "red",  high ="blue",
                       midpoint = 6,  guide = "colourbar", breaks = c(3,6,9, 15))


```


## SI figure of chem variables by date

```{r}
levels <- c("DOC_mgL", "BIX", "HIX", "NO3NO2_ugL", "D_excess")

levels_db <- c("22 May", "19 Jun", "11 Jul", "14 Aug", "16 Sep", 
               "30 Sep", "28 Oct", "17 Dec", "26 Feb", "16 Apr")

#By dates
Chem_by_date_SI_fig <- chem |> 
  pivot_longer(-c(1:8)) |>  
  # filter(!Site %in% c(50,88,90)) |> #if wanting to zoom in on S1 - C1 transition
  filter(name %in% levels) |> 
  mutate(Date1 = format(Date, "%d %b")) |> 
  ggplot(aes(x = Distance, y = value, fill = Depth_m))+
  geom_rect(aes(xmin = Dry_start, xmax = Dry_end, ymin = -Inf, ymax = Inf), 
            alpha = 0.1, fill = "gray", color = NA )+ #color gets rid of border
  geom_point(shape = 21, size = 4) + #shape = 21,
  #geom_smooth()+ # add ', warning=FALSE' to chunk to see plot
  facet_grid(factor(name, levels = levels)~factor(Date1, levels = levels_db), scales = "free_y")+
  theme_bw()+ theme(legend.position = "top", text = element_text(size = 14),
                    axis.text.x = element_text(angle = 45, hjust = 1), #can make angle = 45 and hjust = 1 to shift x label
                    panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= "Distance from Stream (m)", fill = "Depth (m)")+
  scale_x_continuous(breaks = c(0, 600, 1200))+ 
  scale_fill_gradient2(low = "red",  high ="blue",
                       midpoint = 6,  guide = "colourbar", breaks = c(3,6,9, 15))

Chem_by_date_SI_fig

# ggsave("../Figures/Chem_by_Date_SI.png", height = 8, width = 11, units = "in")


```



## Make nice plots of each variable

```{r}

#Faceting
chem |> 
  pivot_longer(-c(1:8)) |> 
  ggplot(aes(x = Distance, y = value, fill = Depth_m))+
  geom_point(shape = 21, size = 3) + #shape = 21,
  theme_bw()+ theme(legend.position = "top", text = element_text(size = 18),
                    panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= "Distance from Stream (m)", fill = "Depth (m)")+
  scale_x_continuous(breaks = c(0, 500, 1000, 1500))+ 
    facet_wrap(~name, scales = "free_y")+
  scale_fill_gradient2(low = "red",  high ="blue",
                       midpoint = 6,  guide = "colourbar", breaks = c(3,6,9, 15))



#### just one variable
#BIX  # bix_clean <- 
chem |> 
  ggplot(aes(x = Distance, y = BIX, fill = Depth_m))+
  #geom_point(shape = 21, size = 3) + #shape = 21,
  geom_jitter(size = 3, shape = 21, width = 10, height = 0)+
  theme_bw()+ theme(legend.position = "top", text = element_text(size = 18),
                    panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= "Distance from Stream (m)", y = "BIX", fill = "Depth (m)",
       shape = "Site Type")+
  scale_x_continuous(breaks = c(0, 500, 1000, 1500))+ 
   scale_fill_gradient2(low = "red",  high ="blue",
                        midpoint = 6,  guide = "colourbar", breaks = c(3,6,9, 15))
  # scale_fill_gradient2(
  #   low = "red",
  #   high = "blue",
  #   midpoint = 6,
  #   guide = "colourbar",
  #   breaks = c(3, 6, 9, 10, 15),   # show ticks beyond 10
  #   limits = c(0, 15),             # extend legend to 15
  #   oob = 
  #   oob = scales::squish           # cap colors at 10
  # )


```




########################### KRUSKAL wallis ###################################

## Normality test

```{r}
#### normality
  ##https://www.sthda.com/english/wiki/normality-test-in-r

ggdensity(chem$BIX, xlab = "BIX", main = "Density plot of BIX in CCR")
shapiro.test(chem$BIX) # p-values < 0.05 means data is not normally distributed
ggdensity(chem$DOC_mgL, xlab = "DOC (mg/L)", main = "Density plot of DOC in CCR")
shapiro.test(chem$DOC_mgL) 
ggdensity(chem$d2H_VSMOW, xlab = "dH2", main = "Density plot of dH2 in CCR")
shapiro.test(chem$d2H_VSMOW) 


```




## Make boxplots across sites for each variable 

Try function for making all the boxplots

```{r}

## first add site type to chem data frame 
chem_kruskal <- chem |> 
  mutate(Site_Type = ifelse(Site_code %in% c("S1", "S2"), "Stream", NA),
         Site_Type = ifelse(Site_code %in% c("B1", "B2"), "Backwater", Site_Type),
         Site_Type = ifelse(Site_code %in% c("C1", "C2"), "Cove", Site_Type),
         Site_Type = ifelse(Site_code %in% c("P1", "P2"), "Pelagic", Site_Type)
         )



library(tidyverse)
library(FSA)
library(rcompanion)
library(ggpubr)
library(rlang)

#### Function

make_kruskal_dunn_plot <- function(df, response_var, group_var = "Site_Type", level_order = c("Stream", "Backwater", "Cove", "Pelagic")) {
  
  group_sym <- rlang::sym(group_var)
  response_sym <- rlang::sym(response_var)
  
  formula <- as.formula(paste(response_var, "~", group_var))
  kruskal <- kruskal.test(formula, data = df)
  dunn <- FSA::dunnTest(formula, data = df)
  dunn_letters <- dunn$res
  
  dunn_letters_list <- rcompanion::cldList(
    comparison = dunn_letters$Comparison,
    p.value = dunn_letters$P.adj,
    threshold = 0.05
  )
  
  df_plot <- df %>%
    left_join(dunn_letters_list, by = setNames("Group", group_var))
  
  # Calculate dynamic label position
  y_max <- max(df[[response_var]], na.rm = TRUE)
  label_y <- y_max + 0.01 * abs(y_max)  # Add 10% buffer above max
  
  p <- ggplot(df_plot, aes(x = factor(!!group_sym, levels = level_order), y = !!response_sym)) +
    geom_boxplot(outlier.alpha = 0) +
    geom_jitter(width = 0.2) +
    stat_compare_means(method = "kruskal.test", label.y = label_y * 1.1, label.x = 1.3, size = 4) +
    geom_text(aes(label = Letter), y = label_y * 1.05, size = 5) +
    theme_bw() +
    theme(#axis.text.x = element_text(angle = 0, hjust = 0), #can make angle = 45 and hjust = 1 to shift x label
          text = element_text(size = 12),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    labs(x = "Site Type", y = response_var)
  
  return(p)
}
 

#### Run function 
response_vars <- c(
                   "BIX", "HIX", "A_T", "SUVA254", 
                   "DOC_mgL", "DN_mgL", "DON_mgL",
                   "NH4_ugL", "NO3NO2_ugL", "SRP_ugL",
                   "d18O_VSMOW", "d2H_VSMOW", "D_excess"
                   )  

# Generate plots for each variable
plots <- lapply(response_vars, function(var) {
  make_kruskal_dunn_plot(chem_kruskal, response_var = var)
})

# Optionally name the plots
names(plots) <- response_vars


#### Make plots 

#view just one
plots[["DOC_mgL"]]  # Or use gridExtra::grid.arrange() to show multiple
plots$BIX

#make a few plots in groups 
library(gridExtra)
gridExtra::grid.arrange(plots$BIX, plots$HIX, plots$A_T, plots$SUVA254, nrow = 1) #EEM
gridExtra::grid.arrange(plots$DOC_mgL, plots$DON_mgL, nrow = 1) #DOM
gridExtra::grid.arrange(plots$NO3NO2_ugL, plots$NH4_ugL, plots$DN_mgL, plots$SRP_ugL, nrow = 1) #Nutrients
gridExtra::grid.arrange(plots$d18O_VSMOW, plots$d2H_VSMOW, plots$D_excess, nrow = 1) #Isotopes



### DOM plot for MS 

# gridExtra::grid.arrange(plots$DOC_mgL, plots$BIX, plots$HIX, plots$A_T, plots$SUVA254, nrow = 2) #EEM


DOM_boxplots_MS <- cowplot::plot_grid(plots$DOC_mgL, plots$BIX, plots$HIX, plots$A_T, plots$SUVA254, labels = c("a", "b", "c", "d", "e"), nrow = 2)

DOM_boxplots_MS

# ggsave("../Figures/DOM_boxplot_MS.png", DOM_boxplots_MS, height = 6, width = 8, units = "in")

#plot all plots at once; too busy for all 13
# library(patchwork)
# wrap_plots(plots) #makes all the plots


##nutrient boxplots for SI
nutrient_boxplots_SI <- cowplot::plot_grid(plots$NO3NO2_ugL, plots$NH4_ugL, plots$SRP_ugL, labels = c("a", "b", "c"), nrow = 1)

 # ggsave("../Figures/Nutrient_boxplot_SI.png", nutrient_boxplots_SI, height = 3, width = 8.5, units = "in")


```


##Some boxplot summary stats

DOC

```{r}

chem_kruskal |> 
  # dplyr::select(Site_Type, DOC_mgL, HIX, BIX, NO3NO2_ugL, D_excess) |> 
  dplyr::select(Site_Type, NO3NO2_ugL) |> 
  group_by(Site_Type) %>%
  summarise(across(
    .cols = where(is.numeric),
    .fns = list(
      mean   = ~mean(.x, na.rm = TRUE),
      median = ~median(.x, na.rm = TRUE),
      min    = ~min(.x, na.rm = TRUE),
      max    = ~max(.x, na.rm = TRUE),
      range  = ~max(.x, na.rm = TRUE) - min(.x, na.rm = TRUE)
    ),
    .names = "{.col}_{.fn}"
  ))


## DOC plot over time
doc_by_day <- chem |> 
  ggplot(aes(x = Distance, y = DOC_mgL, fill = Depth_m))+
  geom_rect(aes(xmin = Dry_start, xmax = Dry_end, ymin = -Inf, ymax = Inf), 
            alpha = 0.1, fill = "gray", color = NA )+ #color gets rid of border
  geom_point(shape = 21, size = 4) +
  facet_wrap(~Date, scales = "fixed")+
  theme_bw()+ theme(legend.position = "top", text = element_text(size = 18),
                    panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= "Distance from Stream (m)", fill = "Depth (m)")+
  scale_x_continuous(breaks = c(0, 500, 1000, 1500))+ 
  scale_fill_gradient2(low = "red",  high ="blue",
                       midpoint = 6,  guide = "colourbar", breaks = c(3,6,9, 15))

doc_by_day
# plotly::ggplotly(doc_by_day)


#DOC range within pelagic sites
chem_kruskal |> filter(Site_Type == "Pelagic") |> 
  dplyr::select(Date, Site_code, DOC_mgL) |> 
  group_by(Date, Site_code) |> 
  summarise(across(
    .cols = where(is.numeric),
    .fns = list(
      mean   = ~mean(.x, na.rm = TRUE),
      median = ~median(.x, na.rm = TRUE),
      min    = ~min(.x, na.rm = TRUE),
      max    = ~max(.x, na.rm = TRUE),
      range  = ~max(.x, na.rm = TRUE) - min(.x, na.rm = TRUE)
    ),
    .names = "{.col}_{.fn}"
  )) |> 
  arrange(Site_code)

```

Nutrients

```{r}
chem |> filter(SRP_ugL > 5)

gridExtra::grid.arrange(plots$NO3NO2_ugL, plots$NH4_ugL, plots$DN_mgL, plots$SRP_ugL, nrow = 1) #Nutrients



```



########################### Breakpoints ###################################

## singular breakpoint

```{r}
### BIX

#fit normal linear regression 
my.lm <- lm(BIX ~ Distance, data = chem)
summary(my.lm)
davies <- davies.test(my.lm, k=10)
davies

#Run breakpoint
my.seg <- segmented(my.lm,  seg.Z = ~ Distance,  psi = 2 )
summary(my.seg)
my.seg$psi
slope(my.seg)

#fit breakpoint segments to distance data
my.fitted <- fitted(my.seg)
my.model <- data.frame(Distance = chem$Distance, BIX_fit = my.fitted)

#get breakpoint lines
#NOTE that this line comes up chopy because its fitting to x axis values that aren't continous (have gaps between c and P sites; fixed later below)
my.lines <- my.seg$psi[ , 2]

#plot
chem |> 
  ggplot(aes(x = Distance, y = BIX, fill = Depth_m))+
  geom_point(shape = 21, size = 4) + #shape = 21,
  # geom_smooth()+
  theme_bw()+ theme(legend.position = "top", text = element_text(size = 18),
                    panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= "Distance from Stream (m)", y = "BIX", fill = "Depth (m)",
       shape = "Site Type")+
  scale_x_continuous(breaks = c(0, 500, 1000, 1500))+ 
  scale_fill_gradient2(low = "red",  high ="blue",
                       midpoint = 6,  guide = "colourbar", breaks = c(3,6,9, 15))+
  #geom_smooth()+
  geom_vline(xintercept = my.lines, linetype = "dashed", size = 1.5) +
  geom_line(data = my.model, aes(x = Distance, y = BIX_fit), size = 1, inherit.aes = FALSE ) 



## get the quick stats by running on variables breakpoint
# #BIX
# my.lm <- lm(BIX ~ Distance, data = chem)
# davies <- davies.test(my.lm, k=10)
# davies
# my.seg <- segmented(my.lm,  seg.Z = ~ Distance,  psi = 2 )
# summary(my.seg)
# my.seg$psi
# slope(my.seg)


```


## Quick Breakpoints for all variables

function to make these 

```{r}

library(tidyverse)
library(segmented)

##### Function

plot_segmented_breakpoint <- function(df, response_var, predictor_var = "Distance", fill_var = "Depth_m", psi_init = NULL) {
  response_sym <- rlang::sym(response_var)
  predictor_sym <- rlang::sym(predictor_var)
  fill_sym <- rlang::sym(fill_var)

  # Use median as default psi if not provided
  if (is.null(psi_init)) {
    psi_init <- quantile(df[[predictor_var]], probs = 0.5, na.rm = TRUE)
  }

  # Base scatter plot
  base_plot <- ggplot(df, aes(x = !!predictor_sym, y = !!response_sym, fill = !!fill_sym)) +
    geom_point(shape = 21, size = 4) +
    theme_bw() +
    theme(legend.position = "top", text = element_text(size = 18),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    labs(x = paste(predictor_var, "(m)"), y = response_var, fill = paste(fill_var, "(m)")) +
    scale_x_continuous(breaks = c(0, 500, 1000, 1500)) +
    scale_fill_gradient2(low = "red", high = "blue", midpoint = 6,
                         guide = "colourbar", breaks = c(3, 6, 9, 15))

  # Fit linear model
  lm_fit <- lm(as.formula(paste(response_var, "~", predictor_var)), data = df)

  # Try segmented fit
  seg_fit <- tryCatch({
    segmented(lm_fit, seg.Z = as.formula(paste("~", predictor_var)), psi = psi_init)
  }, error = function(e) {
    warning(paste("Segmented fit failed for", response_var, ":", e$message))
    return(NULL)
  })

  # If segmented failed, return base plot with note
  if (is.null(seg_fit)) {
    return(base_plot + ggtitle(paste(response_var, "(segmented fit failed)")))
  }

  # Extract fitted values and breakpoints
  fitted_vals <- fitted(seg_fit)
  df_fitted <- data.frame(Distance = df[[predictor_var]], Fitted = fitted_vals)
  breakpoints <- seg_fit$psi[, "Est."]

  # Extract slope and breakpoint summary
  slope_info <- slope(seg_fit)[[predictor_var]]
  bp_text <- paste0("Breakpoint at ", round(breakpoints, 1), " m\n",
                    "Slope 1: ", round(slope_info[1, "Est."], 3), "\n",
                    "Slope 2: ", round(slope_info[2, "Est."], 3))

  # Dynamic label position
  y_max <- max(df[[response_var]], na.rm = TRUE)
  label_y <- y_max + 0.1 * abs(y_max)

  # Final plot
  final_plot <- base_plot +
    geom_vline(xintercept = breakpoints, linetype = "dashed", size = 1.5) +
    geom_line(data = df_fitted, aes(x = Distance, y = Fitted), size = 1, inherit.aes = FALSE) 
    #annotate("text", x = breakpoints + 100, y = label_y, label = bp_text, hjust = 0, size = 5)

  return(final_plot)
}


#### Run Function

# List of response variables to analyze
response_vars <- c(
                   "BIX", "HIX", "A_T", "SUVA254", 
                   "DOC_mgL", "DN_mgL", "DON_mgL",
                   "NH4_ugL", "NO3NO2_ugL", "SRP_ugL",
                   "d18O_VSMOW", "d2H_VSMOW", "D_excess"
                   )  

# Generate segmented plots for each variable
segmented_plots <- lapply(response_vars, function(var) {
  plot_segmented_breakpoint(chem, response_var = var)
})

names(segmented_plots) <- response_vars


#### View plots 

#show all plots
library(patchwork)
wrap_plots(segmented_plots, ncol = 3)

#make a few plots in groups 
library(gridExtra)
#EEMs
gridExtra::grid.arrange(segmented_plots$BIX, segmented_plots$HIX, 
                        segmented_plots$A_T, segmented_plots$SUVA254, nrow = 1) #EEM
#DOM
gridExtra::grid.arrange(segmented_plots$DOC_mgL, segmented_plots$DON_mgL, nrow = 1) #DOM
#Nuts
gridExtra::grid.arrange(segmented_plots$NO3NO2_ugL, segmented_plots$NH4_ugL, 
                        segmented_plots$DN_mgL, segmented_plots$SRP_ugL, nrow = 1) #Nutrients
#Iso
gridExtra::grid.arrange(segmented_plots$d18O_VSMOW, segmented_plots$d2H_VSMOW, 
                        segmented_plots$D_excess, nrow = 1) #Isotopes


```





## Breakpoint function for MS figures

```{r}
library(tidyverse)
library(segmented)
library(rlang)

run_breakpoint_analysis <- function(df, response_var, depth_var = "Depth_m") {
  
  # Convert response variable to symbol
  y <- sym(response_var)
  
  # Fit linear model
  my.lm <- lm(as.formula(paste(response_var, "~ Distance")), data = df)
  
  # Davies test
  davies <- davies.test(my.lm, k = 10)
  
  # Segmented model
  my.seg <- segmented(my.lm, seg.Z = ~ Distance, psi = 2)
  
  # Make regression lines; making a continous distance gradient by 1 meter interval so lines don't jump like above
  dist_gradient <- data.frame(Distance = seq(0, max(df$Distance, na.rm = TRUE), by = 1))
  dist_gradient$fit <- predict(my.seg, newdata = dist_gradient)
  
  # Breakpoint + SE
  my.lines <- my.seg$psi[, 2]
  my.lines.SE <- my.seg$psi[, 3]
  
  # Build plot
  p <- df |>
    ggplot(aes(x = Distance, y = !!y, fill = .data[[depth_var]])) +
    geom_rect(
      aes(
        xmin = (my.lines - my.lines.SE),
        xmax = (my.lines + my.lines.SE),
        ymin = -Inf, ymax = Inf
      ),
      alpha = 0.1, fill = "gray", color = NA
    ) +
    geom_point(shape = 21, size = 4) +
    labs(
      x = "Distance from Stream (m)",
      y = paste0(response_var),
      fill = "Depth (m)"
    ) +
        scale_x_continuous(breaks = c(0, 500, 1000, 1500)) +
    scale_fill_gradient2(
      low = "red", high = "blue", midpoint = 6, #could do median(df[[depth_var]], na.rm = TRUE)
      guide = "colourbar"
    ) +
    geom_vline(xintercept = my.lines, linetype = "dashed", size = 1.5) +
    geom_line(
      data = dist_gradient,
      aes(x = Distance, y = fit),
      size = 1,
      inherit.aes = FALSE
    )+
    ##add labels for site type starting
     annotate("text",
           x = c(0, 189, 336, 1013),
           y = Inf,
           label = c("S1", "B1", "C1", "P1"),
           vjust = -0.5,     # pushes labels above the plotting area
           size = 5) +
  coord_cartesian(clip = "off") +   # allow drawing outside panel
  theme_bw() +
  theme(
    plot.margin = margin(20, 20, 20, 20),  # extra room above
      legend.position = "top",
      text = element_text(size = 14),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
        legend.background = element_blank(),
    legend.box.background = element_blank()
    )
 
  # Return everything as a list
  list(
    plot = p,
    segmented_summary = summary(my.seg),
    segmented_slopes = slope(my.seg),
    davies_test = davies
  )
}


```



#### Breakpoints for MS

set up surface and max depth DFs

```{r}
##make surface only data frame
chem_surf <- chem |> 
  filter(Depth_m == 0.1)

##make max depth only data frame
max_depth_df <- chem |> 
  group_by(Site, Date) |> 
  mutate(max_depth = if_else(Depth_m == max(Depth_m, na.rm = TRUE), "Max", "Not")) |> 
  ungroup() |> 
  filter(max_depth == "Max")

```


BIX breakpoints: all depths, surface, bottom
To interpret stats outputs its easier to run chunk line by line
```{r}
#### BIX 

## BIX across all of chem
BIX_break <- run_breakpoint_analysis(chem, "BIX")
#see plot
BIX_break$plot
#get stats for MS table
BIX_break$davies_test
BIX_break$segmented_summary
BIX_break$segmented_slopes


## BIX surface
BIX_surf_break <- run_breakpoint_analysis(chem_surf, "BIX")
BIX_surf_break$davies_test
BIX_surf_break$segmented_summary
BIX_surf_break$segmented_slopes

## BIX BOT
BIX_bot_break <- run_breakpoint_analysis(max_depth_df, "BIX")
BIX_bot_break$davies_test
BIX_bot_break$segmented_summary
BIX_bot_break$segmented_slopes


#plot breakpoints
BIX_break$plot | BIX_surf_break$plot | BIX_bot_break$plot


```


DOC breakpoints: all depths, surface, bottom 

```{r}
#### DOC 

## DOC across all of chem
DOC_break <- run_breakpoint_analysis(chem, "DOC_mgL")
DOC_break$davies_test
DOC_break$segmented_summary
DOC_break$segmented_slopes

## DOC surface
DOC_surf_break <- run_breakpoint_analysis(chem_surf, "DOC_mgL")
DOC_surf_break$davies_test
DOC_surf_break$segmented_summary
DOC_surf_break$segmented_slopes

## DOC BOT
DOC_bot_break <- run_breakpoint_analysis(max_depth_df, "DOC_mgL")
DOC_bot_break$davies_test
DOC_bot_break$segmented_summary
DOC_bot_break$segmented_slopes


```

DOC / BIX figure for MS 

```{r}
##plot them all
Breakpoints_MS <- cowplot::plot_grid(DOC_break$plot, BIX_break$plot,  
                                     DOC_surf_break$plot,  BIX_surf_break$plot, 
                                     DOC_bot_break$plot, BIX_bot_break$plot,
                                     labels = c("a", "b", "c", "d", "e", "f"), ncol = 2)

Breakpoints_MS

# ggsave("../Figures/DOM_breakpoints_MS.png", Breakpoints_MS, height = 8, width = 8, units = "in")


```



Breakponts for SI figure
SI breakpoints across all depths
```{r}
#### AT
AT_break <- run_breakpoint_analysis(chem, "A_T")
AT_break$davies_test
AT_break$segmented_summary
AT_break$segmented_slopes


#### HIX
HIX_break <- run_breakpoint_analysis(chem, "HIX")
HIX_break$davies_test
HIX_break$segmented_summary
HIX_break$segmented_slopes

#### SUVA
SUVA_break <- run_breakpoint_analysis(chem, "SUVA254")
SUVA_break$davies_test
SUVA_break$segmented_summary
SUVA_break$segmented_slopes


####NO3
NO3_break <- run_breakpoint_analysis(chem, "NO3NO2_ugL")
NO3_break$davies_test
NO3_break$segmented_summary
NO3_break$segmented_slopes


#### make figure
Breakpoints_SI <- cowplot::plot_grid(AT_break$plot, SUVA_break$plot, HIX_break$plot,  NO3_break$plot, 
                                     labels = c("a", "b", "c", "d"), ncol = 1)

Breakpoints_SI

# ggsave("../Figures/DOM_NO3_breakpoints_SI.png", Breakpoints_SI, height = 9, width = 7, units = "in")

```


## Check out adding chla breakpoint 

```{r}
#read in and bind chla data
ccr_chla <- read.csv("../Data/CCR_chla.csv") |> 
  mutate(Date = as.Date(Date))

chla_chem <- full_join(chem, ccr_chla, by = c("Reservoir", "Site", "Date", "Depth_m")) |> 
  filter(!is.na(Chla_ugL))

```

run breakpoint 

```{r}
chla_break_surf <- run_breakpoint_analysis(chla_chem, response_var = "Chla_ugL")

chla_break_surf$plot
chla_break_surf$davies_test
chla_break_surf$segmented_summary
chla_break_surf$segmented_slopes


```

chla breakplot

```{r}
chla_break_plots <- cowplot::plot_grid(NO3_break$plot, chla_break_surf$plot, 
                                       DOC_break$plot,  BIX_break$plot, 
                                     labels = c("a", "b", "c", "d"), ncol = 1)

chla_break_plots

# ggsave("../Figures/Chla_breakpoints_SI.png", chla_break_plots, height = 9, width = 7, units = "in")

```



